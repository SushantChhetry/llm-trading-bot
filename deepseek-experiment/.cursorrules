# Cursor Rules for DeepSeek Trading Bot - Performance Optimized

## ⚠️ CRITICAL: Follow ALL Rules When Writing Code

**YOU MUST follow every rule in this document when generating or modifying code. These are MANDATORY requirements, not suggestions.**

- ✅ **ALWAYS** use type hints on ALL functions
- ✅ **ALWAYS** use async/await for I/O operations
- ✅ **ALWAYS** use `pathlib.Path` for file paths
- ✅ **ALWAYS** follow the import patterns specified below
- ✅ **ALWAYS** place files in the correct directories as specified
- ✅ **ALWAYS** follow naming conventions (snake_case for files/functions, PascalCase for classes)
- ✅ **NEVER** use blocking I/O in async contexts
- ✅ **NEVER** create documentation files unless explicitly requested
- ✅ **NEVER** commit code without type hints
- ✅ **NEVER** use `SELECT *` in database queries

When writing code, reference this file and ensure compliance with ALL sections.

## Core Principles

1. **Performance First**: Every code change must consider latency, throughput, and resource efficiency. Trading decisions happen every 2.5 minutes - optimize for speed.

2. **Code-First Implementation**: Prioritize working code over documentation. Write clean, maintainable code with clear intent. Only create markdown/docs when explicitly requested.

3. **Think Through Architecture**: Analyze problems, edge cases, and design solutions before implementing. Consider performance implications of every decision.

4. **No Documentation by Default**: Do NOT create markdown files (`.md`), analysis documents, summaries, or todo lists unless explicitly requested.

5. **Rule Compliance**: Every line of code must follow ALL rules in this document. No exceptions.

## Performance Optimization Rules

### Async/Await Patterns
- **MANDATORY: ALWAYS use async/await for I/O operations. Blocking I/O is FORBIDDEN.**

  - LLM API calls → Use `httpx.AsyncClient` or `aiohttp`
  - Database queries → Use async database clients (asyncpg, async SQLAlchemy)
  - Exchange API calls → Use async CCXT or async HTTP clients
  - File I/O for logs → Use async logging handlers when possible

  Examples:
  - ❌ NEVER: `requests.get(url)` or `requests.post(url)`
  - ✅ ALWAYS: `async with httpx.AsyncClient() as client: await client.get(url)`

  - ❌ NEVER: `conn.execute(query)` (blocking SQLAlchemy)
  - ✅ ALWAYS: `await conn.execute(query)` (async SQLAlchemy) or `await conn.fetch(query)` (asyncpg)

- **NEVER block the event loop:**
  - ❌ NO synchronous `requests.get()` calls - use `httpx.AsyncClient` instead
  - ❌ NO blocking file operations in hot paths - use `aiofiles` instead
  - ❌ NO `time.sleep()` in async contexts - use `await asyncio.sleep()` instead
  - ✅ Wrap sync operations with `asyncio.to_thread()` or executor if unavoidable

### Database Performance
- **Query Optimization**:
  - Use prepared statements and parameterized queries
  - Fetch only required columns, not `SELECT *`
  - Use database indexes for frequently queried fields (timestamp, symbol, trade_id)
  - Batch database writes (collect multiple inserts/updates, execute in batch)
  - Use connection pooling with appropriate pool size

- **Caching Strategy**:
  - Cache portfolio state in memory with TTL (max 30 seconds for 2.5min cycles)
  - Cache market data with short TTL (5-10 seconds)
  - Cache LLM responses for identical inputs (consider request hashing)
  - Use Redis or in-memory cache for frequently accessed data

### LLM API Efficiency
- **Request Optimization**:
  - Minimize prompt tokens - remove unnecessary context
  - Use streaming responses when possible to reduce latency
  - Implement request queuing to prevent rate limit violations
  - Batch multiple decisions if supported by provider
  - Cache similar decisions (hash market data + portfolio state)

- **Error Handling**:
  - Implement exponential backoff for retries
  - Use circuit breakers to prevent cascade failures
  - Fallback to cached/stale decisions on API failures
  - Log API response times and track latency metrics

### Memory Management
- **For Long-Running Processes**:
  - Limit trade history in memory (keep last N trades, archive older ones)
  - Use generators/yield for large data processing
  - Clear references to large objects when no longer needed
  - Monitor memory usage with `psutil` and log warnings

- **Data Structures**:
  - Use efficient data structures (dicts for O(1) lookups, deque for recent items)
  - Prefer `collections.deque` for trade history with maxlen
  - Use `__slots__` for data classes to reduce memory footprint

### Concurrency & Threading
- **Parallel Processing**:
  - Run independent operations concurrently (data fetching + portfolio calculation)
  - Use `asyncio.gather()` for parallel async operations
  - Use `concurrent.futures.ThreadPoolExecutor` for CPU-bound tasks
  - Don't create more threads/processes than CPU cores

### Error Handling & Resilience
- **Trading System Requirements**:
  - NEVER fail silently on trading operations - always log errors
  - Validate all inputs before executing trades (price, amount, leverage)
  - Use type hints for all function parameters and returns
  - Implement retry logic with exponential backoff for transient failures
  - Use circuit breakers for external API calls

- **Graceful Degradation**:
  - Trading engine should continue with cached/stale data if APIs fail
  - LLM failures should fallback to conservative hold decision
  - Database failures should not stop trading cycles (log to file as backup)

## Code Quality Standards

### Python Best Practices
- **Type Hints**: ALL functions MUST have type hints. Code without type hints is INVALID.
  ```python
  def execute_buy(
      self,
      symbol: str,
      price: float,
      amount: float,
      confidence: float
  ) -> Optional[Dict[str, Any]]:
  ```
  - ❌ NEVER write: `def execute_buy(self, symbol, price, amount):`
  - ✅ ALWAYS write: `def execute_buy(self, symbol: str, price: float, amount: float) -> Optional[Dict[str, Any]]:`

- **PEP 8 Compliance**: Use `black` formatter, `isort` for imports. Code must pass these formatters.
- **Docstrings**: Use Google-style docstrings for all public methods and classes.
- **Imports**: Group imports (stdlib, third-party, local) with blank lines. Follow isort ordering exactly.

### Code Organization
- **Single Responsibility**: Each class/function should do one thing well
- **DRY Principle**: Extract common logic into reusable functions
- **Separation of Concerns**:
  - Trading logic separate from data fetching
  - Business logic separate from I/O operations
  - Configuration separate from implementation

## Project Directory Structure & Organization

### Directory Layout
The project follows this structure at `/deepseek-experiment/`:

```
deepseek-experiment/
├── src/                    # Main application source code
│   ├── main.py            # Entry point (TradingBot orchestrator)
│   ├── trading_engine.py  # Core trading logic & portfolio management
│   ├── data_fetcher.py    # Market data & technical indicators
│   ├── llm_client.py      # LLM API integration
│   ├── logger.py          # Logging configuration
│   ├── security.py        # Security & validation
│   ├── resilience.py      # Retry logic & circuit breakers
│   ├── monitoring.py      # Performance monitoring
│   ├── database_manager.py # Database operations
│   ├── supabase_client.py # Supabase integration
│   └── ...                # Other core modules
├── config/                 # Configuration module
│   └── config.py          # Centralized config settings
├── scripts/                # Utility scripts (not imported by main app)
│   ├── deploy.sh          # Deployment scripts
│   ├── monitor_dashboard.py # Monitoring utilities
│   ├── optimize_strategy.py # Optimization tools
│   └── ...                # Other utility scripts
├── tests/                  # Test files
│   └── test_*.py          # Unit & integration tests
├── docs/                   # Documentation (markdown files)
│   ├── getting-started/   # Quick start guides
│   ├── guides/            # How-to guides
│   └── reference/         # API references
├── data/                   # Data storage (logs, portfolio, trades)
│   ├── logs/              # Application logs
│   └── *.json             # State files (portfolio, trades)
├── experiments/            # Experiment configuration files
│   └── *.yaml             # Experiment configs
├── alembic/                # Database migrations
├── web-dashboard/          # Frontend & API server
│   ├── src/               # React TypeScript frontend
│   ├── api_server.py      # FastAPI backend
│   └── ...
└── [root config files]     # config.yaml, docker-compose.yml, etc.
```

### File Placement Rules

**When creating new files, follow these rules:**

1. **Core Application Modules** → `src/`
   - New trading logic, data processing, or core features
   - Examples: `src/risk_manager.py`, `src/backtest_engine.py`
   - These are imported by `main.py` or other core modules

2. **Utility Scripts** → `scripts/`
   - One-off scripts, deployment tools, analysis scripts
   - Examples: `scripts/analyze_results.py`, `scripts/backup_data.py`
   - These are standalone and NOT imported by the main application

3. **Configuration** → `config/config.py`
   - Add new settings to existing `config.py` file
   - Use environment variables with `os.getenv()` defaults
   - Never create separate config files unless absolutely necessary

4. **Tests** → `tests/`
   - Mirror the `src/` structure: `tests/test_trading_engine.py` for `src/trading_engine.py`
   - Use descriptive names: `test_<module>_<feature>.py`

5. **Documentation** → `docs/`
   - Only create when explicitly requested
   - Follow existing structure: `guides/`, `reference/`, `getting-started/`

### Import Patterns

**MANDATORY: ALWAYS follow these import conventions. Deviating from these patterns is NOT allowed.**

1. **From config module:**
   ```python
   from config import config
   # Access: config.INITIAL_BALANCE, config.LLM_PROVIDER
   ```
   - ❌ NEVER: `from config.config import config` or `import config.config`
   - ✅ ALWAYS: `from config import config`

2. **From src modules (within src/):**
   ```python
   # Use relative imports for same package
   from .logger import get_logger
   from .resilience import retry, circuit_breaker
   from .security import validate_trading_inputs
   ```
   - ❌ NEVER: `from src.logger import get_logger` (when inside src/)
   - ✅ ALWAYS: `from .logger import get_logger` (relative import)

3. **From src modules (from main.py or scripts):**
   ```python
   # Use absolute imports with 'src.' prefix
   from src.trading_engine import TradingEngine
   from src.llm_client import LLMClient
   ```
   - ❌ NEVER: `from .trading_engine import TradingEngine` (when outside src/)
   - ✅ ALWAYS: `from src.trading_engine import TradingEngine` (absolute import)

4. **Import grouping (isort style) - REQUIRED ORDER:**
   ```python
   # 1. Standard library (NO blank line before)
   import json
   import logging
   from datetime import datetime
   from typing import Dict, Optional

   # 2. Third-party (blank line before)
   import httpx
   import pandas as pd

   # 3. Local imports (blank line before)
   from config import config
   from .logger import get_logger
   ```
   - Must have exactly 2 blank lines separating the groups

### File Naming Conventions

- **Modules**: Use snake_case: `trading_engine.py`, `data_fetcher.py`
- **Classes**: Use PascalCase: `TradingEngine`, `DataFetcher`
- **Functions/Variables**: Use snake_case: `execute_buy()`, `portfolio_value`
- **Constants**: Use UPPER_SNAKE_CASE: `MAX_LEVERAGE`, `DEFAULT_INTERVAL`

### Module Responsibilities

**Core modules in `src/` should have clear boundaries:**

- `trading_engine.py`: Trade execution, portfolio management, position tracking
- `data_fetcher.py`: Market data fetching, technical indicators
- `llm_client.py`: LLM API communication, prompt formatting
- `security.py`: Input validation, rate limiting, security checks
- `resilience.py`: Retry logic, circuit breakers, error recovery
- `monitoring.py`: Performance metrics, health checks
- `database_manager.py`: Database operations (Supabase/PostgreSQL)
- `logger.py`: Logging configuration and utilities

**When adding new functionality:**
- If it fits an existing module's responsibility → add to that module
- If it's a new responsibility → create a new module in `src/`
- If it's a one-time utility → add to `scripts/`

### Path Handling

**MANDATORY: ALWAYS use `pathlib.Path` for file paths. NEVER use string concatenation or `os.path.join()`.**

```python
from pathlib import Path

# In config/config.py
PROJECT_ROOT = Path(__file__).parent.parent
DATA_DIR = PROJECT_ROOT / "data"
LOG_DIR = DATA_DIR / "logs"

# In src modules
trades_file = config.DATA_DIR / "trades.json"
```

- ❌ NEVER: `trades_file = os.path.join(config.DATA_DIR, "trades.json")`
- ❌ NEVER: `trades_file = config.DATA_DIR + "/trades.json"`
- ✅ ALWAYS: `trades_file = config.DATA_DIR / "trades.json"`

### Entry Point Pattern

**Main entry point is `src/main.py`:**
- Always add project root to `sys.path` at the top
- Import from both `config` and `src` modules
- Keep orchestration logic minimal (delegate to components)

## Security & Safety

### Trading Safety
- **Input Validation**: Validate all trading parameters:
  - Price > 0, Amount > 0, Leverage within limits (1.0-10.0)
  - Position size within max limits
  - Stop loss/take profit within reasonable bounds

- **Risk Limits**: Enforce risk management rules:
  - Maximum position size per trade
  - Maximum leverage
  - Maximum drawdown thresholds
  - Position count limits

### Security
- **API Keys**: Never log API keys or sensitive credentials
- **Environment Variables**: Use `.env` files, never commit secrets
- **Rate Limiting**: Implement rate limiting for all external APIs
- **Input Sanitization**: Sanitize all user inputs and API responses

## Trading System Specific Rules

### Market Data
- **Data Freshness**: Market data older than 30 seconds is stale
- **Price Validation**: Always validate prices (check for 0, negative, or NaN)
- **Volume Checks**: Consider volume when making trading decisions
- **Technical Indicators**: Cache indicator calculations, reuse where possible

### Portfolio Management
- **State Consistency**: Portfolio state must be consistent across all reads
- **Atomic Operations**: Trading operations must be atomic (all-or-nothing)
- **State Persistence**: Save portfolio state after every trade
- **Performance Metrics**: Calculate metrics efficiently (cache intermediate values)

### LLM Integration
- **Prompt Engineering**: Keep prompts concise but comprehensive
- **Response Parsing**: Always validate JSON responses, handle malformed data gracefully
- **Token Management**: Track and log token usage for cost optimization
- **Response Times**: Monitor and log LLM response times, alert on slowdowns

## File & I/O Operations

### Logging
- **Structured Logging**: Use structured logging with JSON format for production
- **Log Levels**: Use appropriate levels (DEBUG for dev, INFO for production)
- **Log Rotation**: Implement log rotation to prevent disk space issues
- **Performance Logging**: Log execution times for critical operations

### File Operations
- **Async I/O**: Use `aiofiles` for async file operations
- **Atomic Writes**: Use temporary files + rename for atomic writes
- **Error Handling**: Handle file permission errors gracefully

## Database Schema & Migrations

- **Migrations**: Always use Alembic for database schema changes
- **Backwards Compatibility**: Ensure migrations are reversible
- **Indexes**: Add indexes for frequently queried fields
- **Connection Management**: Use connection pooling, close connections properly

## Response Style

- **Be Concise**: Show code changes directly, minimal explanation
- **Action-Oriented**: Focus on "what to do" not "what was done"
- **Code Examples**: Provide code examples inline when explaining concepts
- **Error Messages**: Include actionable error messages with context

## When Documentation IS Needed

Only create markdown/documentation files when:
- User explicitly requests documentation
- User says "create a doc", "write documentation", "create a markdown file"
- User requests summaries or explanations in markdown format

## Performance Monitoring

- **Metrics to Track**:
  - LLM API response times (p50, p95, p99)
  - Trading cycle execution time
  - Database query latency
  - Memory usage trends
  - Error rates and types

- **Alerting**:
  - Alert on LLM API latency > 5 seconds
  - Alert on trading cycle time > 30 seconds
  - Alert on database connection errors
  - Alert on memory usage > 80%

## Example Code Patterns

### Async LLM Call
```python
async def get_trading_decision_async(
    self,
    market_data: Dict[str, Any],
    portfolio_state: Dict[str, Any]
) -> Dict[str, Any]:
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.post(
            self.api_url,
            json={"prompt": prompt, "model": self.model},
            headers={"Authorization": f"Bearer {self.api_key}"}
        )
        response.raise_for_status()
        return response.json()
```

### Cached Portfolio State
```python
from functools import lru_cache
from datetime import datetime, timedelta

@lru_cache(maxsize=1)
def get_cached_portfolio_state(self, timestamp: int) -> Dict[str, Any]:
    # Cache invalidates when timestamp changes (new cycle)
    return self._calculate_portfolio_state()
```

### Batch Database Writes
```python
async def save_trades_batch(self, trades: List[Dict[str, Any]]) -> None:
    async with self.db_pool.acquire() as conn:
        await conn.executemany(
            "INSERT INTO trades (...) VALUES (...)",
            [(t['id'], t['symbol'], ...) for t in trades]
        )
```

---

## Final Reminders

**Before submitting any code:**

1. ✅ Verify ALL functions have type hints
2. ✅ Verify ALL I/O operations use async/await
3. ✅ Verify file paths use `pathlib.Path`
4. ✅ Verify imports follow the exact patterns above
5. ✅ Verify files are placed in correct directories
6. ✅ Verify naming conventions are followed
7. ✅ Run `black` and `isort` on all Python files
8. ✅ Ensure code passes all linter checks

**Remember**: This is a real-time trading system. Every millisecond counts. Optimize aggressively for the critical path (data fetch → LLM decision → trade execution).

**These rules are MANDATORY. Non-compliant code will be rejected.**
